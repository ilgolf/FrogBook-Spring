# Day_12

## 추상화는 모델링이다.

> 객체 지향의 "추상화는 곧 모델링이다"라는 관점을 살펴보자

추상화란 구체적인 것을 분해해서 관찰자가 관심  있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다. 

객체 지향의 4대 특성은 클래스를 통해 구현 된다. 또는 객체라고 할 수 있다. 클래스를 설명하기 전에 먼저 객체를 알아보자

객체 : 세상에 존재하는 유일무이한 사물 

또 이러한 객체는 생물이건 무생물이건 속성과 기능을 갖고 있다고 볼 수 있다.

이에 대비되는 클래스의 정의를 알아 보자

클래스 : 분류, 집합 같은 속성과 기능을 가진 객체를 총칭하는 개념

세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류해 보니 객체를 통칭할 수 있는 집합적 개념, 즉 클래스(분류)가 나오게 된다.

- 객체는 유일무이한 사물이다.
- 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념이다.

예를 들자면, 다음과 같이 표현할 수 있다. 

```java
public class Tv {  // 분류 
    
    private int channel;  // 속성
    private int volume;
    

    void channelUp() {
        channel ++;
    }

    void volumeUp() {
        volume ++;
    }

    public static void main(String[] args) {
        
        Tv samsungTv = new Tv();  // 객체 
        Tv lgTv = new Tv();
        Tv otherTv = new Tv();
    }
}
```

클래스를 객체의 설계도라고 설명하는 말은 바로 이런 과정에서 나왔다고 보면 된다. 붕어빵틀과 붕어빵도 클래스와 객체의 이런 일면만 설명하는 메타포인데, 그걸 클래스와 객체 관계의 전부를 표현하는 메타포로 생각하면 안되는 것이다. 

우리는 객체 지향 프로그래밍을 할 때 클래스를 먼저 설계하게 된다. 그런데 이게 객체 지향의 추상화와 어떤 관계가 있을까? 사람이라는 클래스를 설계한다고 하면 객체들을 관찰해서 먼저 공통된 특성들을 찾아야 한다.

시력, 몸무게, 혈액형, 키, 나이 등 명사로 표현되는 특성인 속성을 부여하고 이 속성들은 값을 가질 수 있다.

먹다, 자다, 일하다, 운전하다, 울다 등등 동사로 표현되는 특성을 기능/행위라고 한다. 이러한 기능/행위는 수행 절차 또는 로직을 갖게된다. 객체 지향에서는 이것을 메서드라고한다.

그렇지만 실제로 사람의 모든 특성을 나열했다가는 엄청난 양의 데이터들이 나올 것이다. 그럴 필요가 있을까?

여기서 또 하나의 개념이 등장하는데 애플리케이션 경계가 이것이다. 컨텍스트라고도 부른다. 

> *"내가 만들고자 하는 애플레케이션은 어디에서 사용될 것인가?"*

만약 병원 애플리케이션을 만들고 있다면 사람은 환자를 의미하는 좀 더 구체적인 이름으로 바꿀 수 있을 것이고 클래스 설계도 달라질 것이다. 은행 애플리케이션을 만들고 있다면 사람은 고객이라는 구체적인 이름으로 바꿀 수 있고 클래스 설계도 역시 달라져야한다.

그리고 또한 이런 설계를 해보니 필요 없는 특성들이 보이기 시작한다.

> 추상화란 구체적인 것을 분해해서 관심 영역에 특성 만을 가지고 재 조합 하는 것

여기서 정의를 IT용어를 이용해 봐꿔보면 다음과 같다.

> 추상화란 구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 있는 특성만 가지고 재조합 하는 것 = 모델링

모델은 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성 만을 추출해서 표현하는 것이다. 객체 지향에서 클래스를 설계할때 모델링(추상화)는 꼭 필요한 기법이고 또 한 데이터베이스의 테이블을 설계할 대 필요한 기법이다. 

중요한 부분을 다시 강조해서 살펴보자

- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 펭귄 : 뽀로로
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야한다.
- 객체 지향에서 추상화의 결과는 클래스다.

사실 추상화 개념을 넓게 본다면 아래 내용도 포함된다.

- 상속을 통한 추상화, 구체화
- 인터페이스를 통한 추상화
- 다형성을 통한 추상화

> 추상화 = 모델링 = 자바 class 키워드

## 추상화와 T 메모리

애니메이션 쥐 캐릭터 관리 프로그램을 만든다고 가정하고 먼저 클래스설계를 해보자 가장 대표적인 캐릭터 2가지로 할 것이다.

[제목 없음](https://www.notion.so/bce4c6b7bba34b3aa5f44f7500f530c2)

그럼 이제 이 캐릭터 객체들을 관찰하여 클래스를 설계해보자 클래스 설계, 즉 모델링에서 제일 중요한 것은 다시 한번 강조하지만 추상화다. 모델을 표현하는 국제 표준 표기법인 UML 클래스 다이어크램으로 쥐 객체를 이용한 클래스 모델링, 즉 추상화 결과는 다음과 같다.

<img src="/static/3-5.PNG" width="91" height="119"></img>

이제 코드로 표한하기 위해 논리적 설계를 물리적 설계로 바꿔야 한다. 논리적 설계는 개발환경에 영향을 받지 않는 설계이며, 개발에 맞춰진 설계다.

<img src="/static/3-6.PNG" width="568" height="182"></img>

자 그러면 이제 설계를 토대로 코드를 작성해보자

```java
public class Mouse {
    private String name;
    private int age;
    private int countOfTail;

    public Mouse(String name, int age, int countOfTail) {
        this.name = name;
        this.age = age;
        this.countOfTail = countOfTail;
    }

    public void sing() {
        System.out.println(name + "찍찍 !!!");
    }
}
```

속성들과 동작으로 표현된 코드를 볼 수 가 있다. 이제 테스트용 클래스를 만들어 보자

(필자는 책과 달리 생성자를 이용하여 객체가 만들어질때 각 속성에 값을 넣어주었다.)

```java
public class MouseDriver {
    
    public static void main(String[] args) {
        Mouse mickey = new Mouse("미키", 85, 1);

        mickey.sing();

        mickey = null;

        Mouse jerry = new Mouse("제리", 73, 1);

        jerry.sing();
    }
}
```

자 그럼 T 메모리 구조는 어떻게 형성될까?

<img src="/static/3-7.PNG" width="513" height="323"></img>

역시 java.lang 패키지와 모든 클래스들이 T메모리의 스태틱 영역에 배치된다. mouse안에 변수에는 값이 저장이 안되어있다. 그저 이름만 존재할 뿐이다. 이 세 개의 속성은 Mouse 클래스에 속한 속성이 아닌 Mouse 객체에 속한 속성이기 때문이다. 객체가 생성되야만 속성의 값을 저장하기 위한 메모리 공간이 힙 영역에 할당된다.

여기서 본 글에는 밑줄이 없지만 실제로 UML 표기법에서 클래스 멤버는 밑줄을, 객체 멤버는 밑줄 없이 표기하기로 약속했기 때문에 main()에는 밑줄이 있어야 하고 sing()에는 존재 하지 않아야 한다. 

그러면 Mouse mickey = new Mouse(...); 에 대해 살펴보자

Mouse mickey

// Mouse 객체에 대한 참조변수 mickey를 만든다.

new Mouse(...)

// Mouse 클래스의 인스턴스를 하나 만들어 힙에 배치한다.

대입문

// Mouse 객체에 대한 주소를 참조 변수 mickey에 할당한다.

그렇다면 mickey를 선언 했을 때 T메모리의 변화를 살펴보자

<img src="/static/3-14.PNG" width="569" height="450"></img>

드디어 힙 메모리에 데이터가 들어왔다! new Mouse("미키", 85, 1) 객체 생성자를 호출하는 동시에 값을 할당 받아서 넣어주었다. 그리고 이 메모리에는 각자의 주소를 갖고 있다. 

예를들어 mickey가 100의 주소 값을 할당 받으면  객체 참조변수 mickey는 해당 주소를 참조하게 되는데 바로 Mouse의 클래스의 인스턴스를 참조하는 것이다.

그 후에 mickey.sing()을 실행하면 T 메모리 상의 변화는 없다. 객체 참조 변수 mickey가 참조하는 Mouse 객체의 sing() 메서드가 코드 실행 영역에서 실행되어 화면에 미키 찍찍!!!을 출력할 것이다.

그 다음 코드를 보면 mickey에 null을 할당하고 있다. 그렇다면 T메모리에 mickey는 더 이상 Mouse 인스턴스를 참조하지 않고 있고 그렇다면 Mouse 객체는 더 이상 쓸모없는 객체이다. 그렇다면 JVM에 있는 가비지컬렉터가 쓰레기로 인지하고 수거해 간다. 

<img src="/static/3-16.PNG" width="569" height="450"></img>

다음과 같이 힙 메모리에 데이터가 없어질 것이다. 그리고 이어서 jerry 참조변수가 만들어지고 같은 과정을 반복하고 JVM이 종료가 될 것이다.